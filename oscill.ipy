# =============================================================================
# This is an ipython script. Make sure to run with ipython from IDE or command line
# Using ipython prevents the app from closing until the user closes it
# If run with regular python, the app will close whenever an error occurs
# =============================================================================

# =============================================================================
# Most settings are configured in GUI
# One thing that needs to be manually changed in the code is file naming convention
# This is done in set_crop function
# =============================================================================

# -*- coding: utf-8 -*-
"""
Created on Tue Aug  8 10:58:07 2017

@author: Kate Khazoyan
"""

#general and image analysis imports
import numpy as np
import math
import os
import csv
from skimage import io
from skimage import morphology 
from skimage import filters
from skimage import measure
from skimage.morphology import watershed
from skimage.morphology import extrema
from scipy import ndimage
from matplotlib import cm
from matplotlib.figure import Figure #better to use this than pyplot with GUI

#qt and gui imports
import sys
from PyQt5 import QtWidgets

#script that sets up gui - designed in Qt Designer and python code autogenerated 
import OscillGUI

#matplotlib imports for embedding in gui
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas, NavigationToolbar2QT as NavigationToolbar

# =============================================================================
# Create var class for global variables so can reassign within functions easily
# When use within OscillApp class, reference as var.variable_name
# Could make attributes of OscillApp, but that seemed more confusing
# Initialize here so easy to keep track of var attributes
# Source: https://pythonconquerstheuniverse.wordpress.com/2010/10/20/a-globals-class-pattern-for-python/
# =============================================================================
class var: 
    #variables
    n = 0 #number of images
    imaging_time = 0 #in hours
    length_conversion = 0 #in pix/mm
    area_conversion = 0 #in pix^2/mm^2
    im_rows = 0 #size of original image
    im_columns = 0
    update = False #flag so figures/plots are updated at right times
    
    #lists
    imnames = []
    area_pix = []
    radius_um = []
    minor_axis = []
    major_axis = []
    ratio = []
    angle = []
    COM_r = [] #in cropped image
    COM_c = []
    com_r = [] #in full image, for tracking
    com_c = []
    crop_r = [] #rows included in crop on each side of center
    crop_c = []

# =============================================================================
# Class for figures and axes so can easily access in all functions
# Like var, reference as fig.fig_name
# =============================================================================
class fig:
    rect = 0,0,1,1  #want images to fill figure; adding axes with rect worked better than adding subplot
    #figures for displaying images
    full_im_fig = Figure()
    full_im_ax = full_im_fig.add_axes(rect)
    full_im_ax.axis('off')
    
    im_crop_fig = Figure()
    im_crop_ax = im_crop_fig.add_axes(rect)
    im_crop_ax.axis('off')
    
    segmented_fig = Figure()
    segmented_ax = segmented_fig.add_axes(rect)
    segmented_ax.axis('off')
    
    ellipse_fit_fig = Figure()
    ellipse_fit_ax = ellipse_fit_fig.add_axes(rect)
    ellipse_fit_ax.axis('off')
    
    #figures for displaying plots
    radius_fig = Figure()
    radius_ax = radius_fig.add_subplot(111)
    radius_fig.set_tight_layout(True)
    radius_ax.set_xlabel('Time(hr)')
    radius_ax.set_ylabel('Radius(um)')
    
    ratio_fig = Figure()
    ratio_ax = ratio_fig.add_subplot(111)
    ratio_fig.set_tight_layout(True)
    ratio_ax.set_xlabel('Time(hr)')
    ratio_ax.set_ylabel('Aspect ratio (1 is circle)')
    
    angle_fig = Figure()
    angle_ax = angle_fig.add_subplot(111) 
    angle_fig.set_tight_layout(True)
    angle_ax.set_xlabel('Time(hr)')
    angle_ax.set_ylabel('Angle(rad)')

# =============================================================================
# All code for controlling GUI is contained within OscillApp class
# An instance of this class is created in main() to open the GUI
# =============================================================================
class OscillApp(QtWidgets.QMainWindow, OscillGUI.Ui_MainWindow):
    #_init_ runs automatically and contains all the code to set up GUI 
    def __init__(self, parent=None):
        super(OscillApp, self).__init__(parent)
        self.setupUi(self) #this sets up everything in OscillGUI.py
        
        # =============================================================================
        # Need figure canvases to make it possible to display matplotlib figures in GUI
        # This functionality isn't included in Qt Designer, so have to add here
        # Empty layouts are created in Qt Designer, then can add widgets to layouts manually
        # Toolbars are added to plots; toolbar takes widget being added to and one parent
        # =============================================================================
        self.full_im_canvas = FigureCanvas(fig.full_im_fig)
        self.full_im_layout.addWidget(self.full_im_canvas)
        
        self.cropped_im_canvas = FigureCanvas(fig.im_crop_fig)
        self.cropped_im_layout.addWidget(self.cropped_im_canvas)
                
        self.segmented_canvas = FigureCanvas(fig.segmented_fig)
        self.segmented_layout.addWidget(self.segmented_canvas)
        
        self.ellipse_fit_canvas = FigureCanvas(fig.ellipse_fit_fig)
        self.ellipse_fit_layout.addWidget(self.ellipse_fit_canvas)
        
        self.radius_canvas = FigureCanvas(fig.radius_fig)
        self.radius_layout.addWidget(self.radius_canvas)
        self.radius_toolbar = NavigationToolbar(self.radius_canvas, self)
        self.radius_layout.addWidget(self.radius_toolbar)
        
        self.ratio_canvas = FigureCanvas(fig.ratio_fig)
        self.ratio_layout.addWidget(self.ratio_canvas)
        self.ratio_toolbar = NavigationToolbar(self.ratio_canvas, self)
        self.ratio_layout.addWidget(self.ratio_toolbar)
        
        self.angle_canvas = FigureCanvas(fig.angle_fig)
        self.angle_layout.addWidget(self.angle_canvas)
        self.angle_toolbar = NavigationToolbar(self.angle_canvas, self)
        self.angle_layout.addWidget(self.angle_toolbar)
        
        # =============================================================================
        # Need to connect buttons, other widgets to the functions that control the GUI
        # For buttons, want function called when buttons clicked
        # For widgets with values, can set to call function when value changes
        # Can also set defaults, disable widgets
        # =============================================================================
        #button initializations
        self.submit_settings_button.clicked.connect(self.set_crop)
        self.set_crop_button.clicked.connect(self.set_segmentation)
        self.start_button.clicked.connect(self.run_loop)
        self.save_button.clicked.connect(self.write_csv)
        self.basic_radio_button.toggled.connect(self.enable_disable)
        self.watershed_radio_button.toggled.connect(self.enable_disable)
        self.image_folder_button.clicked.connect(self.select_image_folder)
        self.save_folder_button.clicked.connect(self.select_save_folder)
        
        #disabled pause button because not working correctly because app freezes up 
        #self.pause_button.clicked.connect(self.pause_clicked)
        self.pause_button.setEnabled(False)
        
        #slider and spin box initializations
        self.COM_rows.valueChanged.connect(self.new_crop)
        self.COM_columns.valueChanged.connect(self.new_crop)
        self.ideal_crop.valueChanged.connect(self.new_crop)
        self.starting_image.valueChanged.connect(self.set_segmentation)
        self.h.valueChanged.connect(self.set_segmentation)
        self.size_filter.valueChanged.connect(self.set_segmentation)
        
        #radio button defaults - dark background (temp gradient) and basic segmentation
        self.dark_radio_button.setChecked(True)
        self.basic_radio_button.setChecked(True)
        
        #default to h disabled because default to basic segmentation
        self.h.setEnabled(False)
        
        #status when program first starts
        self.statusBar().showMessage("Waiting for image folder and settings.")
        
        #initialize pause to be false (if get pause button working)
        #self.pause = False
    
    # =============================================================================
    # Functions for basic GUI control
    # Called by button clicks/toggles
    # Can add default location to getExistingDirectory to make navigation easier
    # =============================================================================
    def select_image_folder(self):
        image_folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Choose Image Folder')
        self.image_folder.setText(image_folder)
        
    def select_save_folder(self):
        save_folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Choose Save Folder')
        self.save_folder.setText(save_folder)
        
    def pause_clicked(self):
        self.pause = True
    
    #Enables/disables size filter, h depending on type of segmentation using
    def enable_disable(self):
        if self.basic_radio_button.isChecked() == True:
            self.size_filter.setEnabled(True)
            self.h.setEnabled(False)
        else:
            self.size_filter.setEnabled(False)
            self.h.setEnabled(True)
   
    # =============================================================================
    # Function: set_crop
    # Called by button click
    # Gets imaging sets, displays first images, and shows default crop
    # Need to change file naming convention manually
    # =============================================================================
    def set_crop(self):
        self.statusBar().showMessage("Waiting for crop of first image to be set (in set crop function).")
        
        #pull imaging settings from UI
        imdir = self.image_folder.text()
        files = os.listdir(imdir)
        var.imaging_time = self.imaging_time.value()
        var.length_conversion = self.length_conversion.value()
        var.area_conversion = var.length_conversion**2 #compute area conversion

        #find all tif files in folder
        images = []
        for names in files:
            if names.endswith('.tif'):
                images.append(names)
                
        var.n = len(images) #number of images
        var.time = np.linspace(0,var.imaging_time,num=var.n) #make array of times
        
        #create list of filenames
        for i in range(0,var.n):
           var.imnames.append(imdir + '/IMG_' + str(i+1) + '.tif')
        
        #read first image and get size
        im = io.imread(var.imnames[0], as_grey=True)
        var.im_rows = im.shape[0]
        var.im_cols = im.shape[1]
        rows_half = int(var.im_rows/2)
        cols_half = int(var.im_cols/2)
        
        #set range of sliders
        self.COM_rows.setMinimum(0)
        self.COM_rows.setMaximum(var.im_rows)
        self.COM_columns.setMinimum(0)
        self.COM_columns.setMaximum(var.im_cols)
        
        #set slider defaults to center of image
        self.COM_rows.setValue(rows_half)
        self.COM_columns.setValue(cols_half)
        
        #display first image
        fig.full_im_ax.imshow(im, cmap=cm.gray, aspect='equal')
        self.full_im_canvas.draw()
        
        #compute default crop using ideal crop and sliders defaults
        var.com_r.append(self.COM_rows.value())
        var.com_c.append(self.COM_columns.value())
        ideal_crop = self.ideal_crop.value()
        
        var.crop_r.append(min(ideal_crop, var.im_rows-var.com_r[0], var.com_r[0]-1))
        var.crop_c.append(min(ideal_crop, var.im_cols-var.com_c[0], var.com_c[0]-1))
        im_crop = im[(var.com_r[0]-var.crop_r[0]):(var.com_r[0]+var.crop_r[0]),(var.com_c[0]-var.crop_c[0]):(var.com_c[0]+var.crop_c[0])]
        
        #display default crop
        fig.im_crop_ax.imshow(im_crop, cmap=cm.gray, aspect ='equal')
        self.cropped_im_canvas.draw()
        
    # =============================================================================
    # Function: new_crop
    # Called when either slider or ideal crop value changes
    # Creates and displays crop based on ideal crop, current slider positions     
    # =============================================================================
    def new_crop(self):
        self.statusBar().showMessage("Waiting for crop of first image to be set (in new crop function).")
        
        #pull values from sliders and ideal crop
        #rewrite com_r, com_c values if already exist, otherwise append lists
        if len(var.com_r) >= 1:
            var.com_r[0] = self.COM_rows.value()
            var.com_c[0] = self.COM_columns.value()
        else:
            var.com_r.append(self.COM_rows.value())
            var.com_c.append(self.COM_columns.value())
        
        ideal_crop = self.ideal_crop.value() 
        
        im = io.imread(var.imnames[0], as_grey=True) #read image again because local variable
       
        #make and display new crop
        if len(var.crop_r) >= 1:
            var.crop_r[0] = min(ideal_crop, var.im_rows-var.com_r[0], var.com_r[0]-1)
            var.crop_c[0] = min(ideal_crop, var.im_cols-var.com_c[0], var.com_c[0]-1)
        else:
            var.crop_r.append(min(ideal_crop, var.im_rows-var.com_r[0], var.com_r[0]-1))
            var.crop_c.append(min(ideal_crop, var.im_cols-var.com_c[0], var.com_c[0]-1))
        
        im_crop = im[(var.com_r[0]-var.crop_r[0]):(var.com_r[0]+var.crop_r[0]),(var.com_c[0]-var.crop_c[0]):(var.com_c[0]+var.crop_c[0])]
        
        #display new crop 
        fig.im_crop_ax.clear()
        fig.im_crop_ax.imshow(im_crop, cmap=cm.gray, aspect='equal')
        fig.im_crop_ax.axis('off')
        self.cropped_im_canvas.draw()
        
    # =============================================================================
    # Function: set_segmentation
    # Called by button click, value changes, and by run_loop 
    # Creates crop of current starting image and calls segment_and_measure
    # =============================================================================
    def set_segmentation(self):
        var.update = True #flag so figures are updated
        
        self.statusBar().showMessage("Waiting for watershed to be set for starting image.")
        
        start = self.starting_image.value()
        im = io.imread(var.imnames[start], as_grey=True)
        
        im_crop = im[(var.com_r[start]-var.crop_r[start]):(var.com_r[start]+var.crop_r[start]),(var.com_c[start]-var.crop_c[start]):(var.com_c[start]+var.crop_c[start])]            
        
        self.segment_and_measure(start,im_crop)        
        var.update = False #reset flag
    
    # =============================================================================
    # Function: run_loop
    # Called by button click
    # Loops through all of the images
    # Calls segment_and_measure and tracks cropping for each image
    # Pauses periodically (interval set in GUI)
    # Automatic pausing chosen because pause button wasn't working correctly
    # =============================================================================
    def run_loop(self):
        var.update = False #false because only want figures to update when paused
        self.statusBar().showMessage("Analysis loop is running.")
        
        start = self.starting_image.value()
        ideal_crop = self.ideal_crop.value()
        
        for i in range(start,var.n):
            msg = 'Analysis loop is running. (i=' + str(i) + ')'
            self.statusBar().showMessage(msg)
            
            #read image and create crop
            im = io.imread(var.imnames[i], as_grey=True)
            
            #rewrite values if this image has been processed before, otherwise append lists 
            if len(var.crop_r) >= i+1:
                var.crop_r[i] = min(ideal_crop, var.im_rows-var.com_r[i], var.com_r[i]-1)
                var.crop_c[i] = min(ideal_crop, var.im_cols-var.com_c[i], var.com_c[i]-1)
            else:
                var.crop_r.append(min(ideal_crop, var.im_rows-var.com_r[i], var.com_r[i]-1))
                var.crop_c.append(min(ideal_crop, var.im_cols-var.com_c[i], var.com_c[i]-1))
            
            im_crop = im[(var.com_r[i]-var.crop_r[i]):(var.com_r[i]+var.crop_r[i]),(var.com_c[i]-var.crop_c[i]):(var.com_c[i]+var.crop_c[i])] 
           
            #segment and measure
            self.segment_and_measure(i,im_crop)

            #tracking for cropping
            if len(var.com_r) >= i+2:   
                var.com_r[i+1] = int(var.com_r[i] - var.crop_r[i] - 1 + var.COM_r[i]) #position in current uncropped image
                var.com_c[i+1] = int(var.com_c[i] - var.crop_c[i] - 1 + var.COM_c[i])
            else:
                var.com_r.append(int(var.com_r[i] - var.crop_r[i] - 1 + var.COM_r[i]))
                var.com_c.append(int(var.com_c[i] - var.crop_c[i] - 1 + var.COM_c[i]))
            
           #pause periodically to check plots, reset segmentation if necessary
            interval = self.pause_interval.value()
            if i%interval==0 and i!=0:
                if self.move_on.isChecked()==False:
                    break #break loop and call set_segmentation if not satisfied with interval's results
                else:
                   self.move_on.setChecked(False) #reset check box
            
            
            #use this for breaking loop if using pause button
#            if self.pause:
#                self.stop = False
#                break
            
        #if loop broke before reaching end, call set_segmentation
        if len(var.area_pix) < var.n:
            self.set_segmentation()
            
        #if loop gets all the way through n, then wait for save button to be pushed
        else:
            self.statusBar().showMessage("Loop is finished. Waiting for save filename and folder.")
        
    # =============================================================================
    # Function: write_csv
    # Called by button click
    # Pulls save folder, filename from GUI and saves results to csv
    # =============================================================================
    def write_csv(self):
        #save csv file
        self.statusBar().clearMessage()
        
        savedir = self.save_folder.text()
        filename = self.filename.text()
        
        save_file = savedir + '/' + filename + '.csv'
        headers = ['Time(hr)', 'Radius(um)', 'Aspect Ratio(1 is circle)', 'Angle(rad)']
    
        with open(save_file, 'w') as csvfile:
            filewriter = csv.writer(csvfile) 
            filewriter.writerow(headers) #write first row (column headers)
            
            for i in range(1,var.n): #write row for each image
                filewriter.writerow([var.time[i], var.radius_um[i], var.ratio[i], var.angle[i]])
        
        self.statusBar().showMessage("Results saved to csv.")
        
    # =============================================================================
    # Function: segment_and_measure
    # Called by set_segmentation, run_loop
    # Segments current cropped image using either basic or watershed algorithm
    # Measures relevant quantities of segmented object and updates lists
    # =============================================================================
    def segment_and_measure(self, i, im_crop):
        self.statusBar().showMessage("In segment and measure function.")
        if self.basic_radio_button.isChecked() == True:
            #basic segmentation algorithm
            size_filter = self.size_filter.value()
            se_basic = morphology.square(5) #structuring element for morphological closing
            level = filters.threshold_otsu(im_crop)
            bw = im_crop > level #create binary image based on grayscale level
            
            if self.light_radio_button.isChecked() == True: #flip black/white if background lighter than object
                bw = ~bw
            
            bw2 = morphology.closing(bw,se_basic) #close image to clean up edges
            bw3 = morphology.remove_small_objects(bw2,size_filter) #remove any objects smaller than size filter (small debris)
            bw4 = ndimage.morphology.binary_fill_holes(bw3) #fill holes in object
            labels= morphology.label(bw4) #label objects
            props = measure.regionprops(labels) #measure objects

        else:
            #watershedding algorithm
            h = self.h.value()
            se_ws = morphology.disk(10) #structuring element for morphological closing
            closed = morphology.closing(im_crop,se_ws) #close image to remove local noise in grayscale levels
            level = filters.threshold_otsu(closed)
            bw = closed > level #create binary image based on grayscale level
            
            if self.light_radio_button.isChecked() == True: #flip black/white if background lighter than object
                bw = ~bw
            
            distance = ndimage.distance_transform_edt(bw) #compute distance transform
            local_maxi = extrema.h_maxima(distance, h) #find maxima of height h in distance transform
            markers = morphology.label(local_maxi) #use maxima as markers for watershed 
            labels = watershed(-distance,markers,mask=bw) #compute watershed of distance transform 
            props = measure.regionprops(labels) #measure objects
        
        #assume object with largest area is the tissue piece
        temp = 0
        for j in range(0,len(props)):
            if props[j].area > temp:
                temp = props[j].area
                biggest = j
        
        centroid = props[biggest].centroid #row and column of object's centroid
                        
        #need to append to create list if first time, otherwise rewrite
        #if list initialized, but nothing added, len == 0
        if len(var.area_pix)>= i+1:
            var.area_pix[i] = props[biggest].area
            var.major_axis[i] = props[biggest].major_axis_length
            var.minor_axis[i] = props[biggest].minor_axis_length
            var.angle[i] = props[biggest].orientation    #in rad, -pi/2 to pi/2
            var.COM_r[i] = centroid[0]
            var.COM_c[i] = centroid[1]
            var.radius_um[i] = math.sqrt((var.area_pix[i]/var.area_conversion)/math.pi) * 1000
            var.ratio[i]= var.minor_axis[i]/var.major_axis[i]
            
        else:
            var.area_pix.append(props[biggest].area)
            var.major_axis.append(props[biggest].major_axis_length)
            var.minor_axis.append(props[biggest].minor_axis_length)
            var.angle.append(props[biggest].orientation)
            var.COM_r.append(centroid[0])
            var.COM_c.append(centroid[1])
            var.radius_um.append(math.sqrt((var.area_pix[i]/var.area_conversion)/math.pi) * 1000)
            var.ratio.append(var.minor_axis[i]/var.major_axis[i])
        
        #call plot_and_draw to update figures 
        interval = self.pause_interval.value()
        if i == 0 or i%interval==0 or var.update == True:
            self.plot_and_draw(i,im_crop,labels)
                
    # =============================================================================
    # Function: plot_and_draw
    # Called by segment_and_measure
    # Updates segmentated and ellipse fit images, and plots results
    # =============================================================================
    def plot_and_draw(self, i, im_crop, labels):
        #show segmented image
        fig.segmented_ax.clear()
        fig.segmented_ax.imshow(labels, cmap=cm.PuBuGn, aspect='equal')
        fig.segmented_ax.axis('off')
        self.segmented_canvas.draw()
        
        #draw fitted ellipse
        t = np.linspace(0,2*math.pi,num=50)
        a = var.major_axis[i]/2
        b = var.minor_axis[i]/2
        Xc = var.COM_c[i]
        Yc = var.COM_r[i]
        phi = -var.angle[i]
        ellipx = Xc + a*np.cos(t)*np.cos(phi) - b*np.sin(t)*np.sin(phi)
        ellipy = Yc + a*np.cos(t)*np.sin(phi) + b*np.sin(t)*np.cos(phi)
    
        #draw lines along the axes
        xMajor = [Xc - a*np.cos(phi), Xc + a*np.cos(phi)]
        yMajor = [Yc - a*np.sin(phi), Yc + a*np.sin(phi)]
    
        xMinor = [Xc - b*np.cos(phi - math.pi/2), Xc + b*np.cos(phi - math.pi/2)]
        yMinor = [Yc - b*np.sin(phi - math.pi/2), Yc + b*np.sin(phi - math.pi/2)]
    
        #overlay cropped im and ellipse fit
        fig.ellipse_fit_ax.clear()
        fig.ellipse_fit_ax.axis('off')
        fig.ellipse_fit_ax.imshow(im_crop, cmap=cm.gray, aspect='equal')
        fig.ellipse_fit_ax.plot(ellipx,ellipy, color ='m', linewidth = 2.0)
        fig.ellipse_fit_ax.plot(xMajor,yMajor, color ='m', linewidth = 2.0)
        fig.ellipse_fit_ax.plot(xMinor,yMinor, color ='m', linewidth = 2.0)
        self.ellipse_fit_canvas.draw()
        
        #update plots
        #pausing automatically whenever update plots because pause button not working
        interval = self.pause_interval.value() #pull interval value from GUI
        if i%interval==0 and i!=0:
            self.starting_image.setValue(i) #change start im value to match figures, plots
            
            #update all 3 plots
            fig.radius_ax.clear()
            fig.radius_ax.plot(var.time[0:i],var.radius_um[0:i], '.:')
            fig.radius_ax.autoscale(enable=True, axis = 'both')
            fig.radius_ax.set_xlabel('Time(hr)')
            fig.radius_ax.set_ylabel('Radius(um)')
            self.radius_canvas.draw()
            
            fig.ratio_ax.clear()
            fig.ratio_ax.plot(var.time[0:i],var.ratio[0:i], '.:')
            fig.ratio_ax.autoscale(enable=True, axis = 'both')
            fig.ratio_ax.set_xlabel('Time(hr)')
            fig.ratio_ax.set_ylabel('Aspect ratio (1 is circle)')
            self.ratio_canvas.draw()
            
            fig.angle_ax.clear()
            fig.angle_ax.plot(var.time[0:i],var.angle[0:i], '.:')
            fig.angle_ax.autoscale(enable=True, axis = 'both')
            fig.angle_ax.set_xlabel('Time(hr)')
            fig.angle_ax.set_ylabel('Angle(rad)')
            self.angle_canvas.draw()
   
#Run app
def main():
    app = QtWidgets.QApplication(sys.argv)
    form = OscillApp()
    form.show()
    app.exec_()
    
if __name__ == "__main__":
    main()